import { parse } from "@babel/parser";
import traverse, { NodePath } from "@babel/traverse";
import { mkdirSync, readFileSync, writeFileSync } from "fs";
import { resolve } from "path";
import { BabelFileResult, transformSync } from "@babel/core";
import { parseTypeAnnotation, parseCommentBlock } from "../utils/parser";

const showSample = () => {
  const projectRoot = resolve(__dirname, "../source");

  const path = resolve(projectRoot, "sample.tsx");

  const esNextCode: string = readFileSync(path).toString();

  console.log("transform......");

  const babelParseResult: BabelFileResult | null = transformSync(esNextCode, {
    filename: resolve(__dirname, "../error/error.ts"),
  });

  if (!babelParseResult) {
    console.log("transform failed");
    return;
  }

  const { code: es5Code } = babelParseResult!;

  console.log("parse......");

  const ast = parse(esNextCode, {
    sourceType: "module",
    plugins: [
      "jsx",
      "typescript",
      "asyncGenerators",
      "bigInt",
      "classProperties",
      "classPrivateProperties",
      "classPrivateMethods",
      ["decorators", { decoratorsBeforeExport: false }],
      "doExpressions",
      "dynamicImport",
      "exportDefaultFrom",
      "exportNamespaceFrom",
      "functionBind",
      "functionSent",
      "importMeta",
      "logicalAssignment",
      "nullishCoalescingOperator",
      "numericSeparator",
      "objectRestSpread",
      "optionalCatchBinding",
      "optionalChaining",
      ["pipelineOperator", { proposal: "minimal" }],
      "throwExpressions",
      "topLevelAwait",
      "estree",
    ],
  });

  console.log("Starting writing to out directory......");

  writeFileSync("./out/esNextCode.json", esNextCode);
  writeFileSync("./out/es5Code.json", es5Code ?? "");
  writeFileSync("./out/ast.json", JSON.stringify(ast, null, 2));

  console.log("Traversing to collect interface......");

  const interfaceCollection: any[] = [];

  traverse(ast, {
    enter: (path) => {
      if (path.node.type === "TSInterfaceDeclaration") {
        const operator = "extends" in path.node ? "unshift" : "push"; // 含extends放前面
        interfaceCollection[operator](path.node);
      }
    },
  });

  writeFileSync(
    "./out/interface.json",
    JSON.stringify(interfaceCollection, null, 2)
  );

  const mdTitle = "## API";

  const mdTemplate = [
    "| 属性名 | 描述 | 类型 | 必需 | 默认值",
    "| ----------- | ----------- |---------- |---------- |---------- |",
  ];

  const extraInfo = [
    "The API Document is generated by typescript-doc-gen!",
    "Author: Oliver <matthrews@outlook.com>",
    "License: MIT",
    "Repo: https://github.com/Matthrews/typescript-doc-gen",
  ];

  const bodyContent: string[] = [];

  interfaceCollection.forEach((interfaceItem) => {
    const {
      id: { name = "" },
      body: { body: properties = [] },
    } = interfaceItem;
    const contents = [`### ${name}\r\n`].concat(mdTemplate);

    properties.forEach((property) => {
      const {
        optional,
        key: { name = "" },
        leadingComments: [{ value = "" }],
        typeAnnotation: { typeAnnotation = {} },
      } = property;
      const type = parseTypeAnnotation(typeAnnotation);
      const required = optional ? "--" : "是";
      const comment = parseCommentBlock(value);
      const defaultValue = parseCommentBlock(value, "default") || "--";
      contents.push(
        `| ${name} | ${comment} | <code>${type}</code> | <code>${required}</code> | <code>${defaultValue}</code> |`
      );
    });

    contents.push("\r\n");

    bodyContent.push(contents.join("\r\n"));
  });

  const result = [mdTitle].concat(bodyContent).concat(extraInfo).join("\r\n");

  writeFileSync("./markdown/API.md", result);

  console.log("Finished!");
};

const presets = [
  [
    "@babel/preset-env",
    {
      modules: false,
    },
  ],
  "@babel/preset-react",
  [
    "@babel/preset-typescript",
    {
      isTSX: true,
      allExtensions: true,
      allowDeclareFields: true,
    },
  ],
];
const plugins = [
  ["@babel/plugin-proposal-decorators", { legacy: true }],
  ["@babel/plugin-proposal-class-properties", { loose: true }],
  ["@babel/plugin-proposal-private-methods", { loose: true }],
  ["@babel/plugin-syntax-dynamic-import"],
  ["@babel/plugin-transform-runtime"],
  ["@babel/plugin-transform-modules-commonjs"],
];

const generateDoc = (path: string, outDir: string = "./out") => {
  console.log("generateDoc", path, outDir);
  const esNextCode: string = readFileSync(path).toString();

  console.log("transform......");

  const babelParseResult: BabelFileResult | null = transformSync(esNextCode, {
    filename: resolve(__dirname, "../error/error.ts"),
    configFile: false,
    presets,
    plugins,
  });

  if (!babelParseResult) {
    console.log("transform failed");
    return;
  }

  const { code: es5Code } = babelParseResult!;

  console.log("parse......");

  const ast = parse(esNextCode, {
    sourceType: "module",
    plugins: [
      "jsx",
      "typescript",
      "asyncGenerators",
      "bigInt",
      "classProperties",
      "classPrivateProperties",
      "classPrivateMethods",
      ["decorators", { decoratorsBeforeExport: false }],
      "doExpressions",
      "dynamicImport",
      "exportDefaultFrom",
      "exportNamespaceFrom",
      "functionBind",
      "functionSent",
      "importMeta",
      "logicalAssignment",
      "nullishCoalescingOperator",
      "numericSeparator",
      "objectRestSpread",
      "optionalCatchBinding",
      "optionalChaining",
      ["pipelineOperator", { proposal: "minimal" }],
      "throwExpressions",
      "topLevelAwait",
      "estree",
    ],
  });

  console.log("Starting writing to out directory......");

  mkdirSync(outDir);

  writeFileSync(`${outDir}\\esNextCode.json`, esNextCode);
  writeFileSync(`${outDir}\\es5Code.json`, es5Code ?? "");
  writeFileSync(`${outDir}\\ast.json`, JSON.stringify(ast, null, 2));

  console.log("Traversing to collect interface......");

  const interfaceCollection: any[] = [];

  traverse(ast, {
    enter: (path) => {
      if (path.node.type === "TSInterfaceDeclaration") {
        const operator = "extends" in path.node ? "unshift" : "push"; // 含extends放前面
        interfaceCollection[operator](path.node);
      }
    },
  });

  writeFileSync(
    `${outDir}\\interface.json`,
    JSON.stringify(interfaceCollection, null, 2)
  );

  const mdTitle = "## API";

  const mdTemplate = [
    "| 属性名 | 描述 | 类型 | 必需 | 默认值",
    "| ----------- | ----------- |---------- |---------- |---------- |",
  ];

  const extraInfo = [
    "The API Document is generated by typescript-doc-gen!",
    "Author: Oliver <matthrews@outlook.com>",
    "License: MIT",
    "Repo: https://github.com/Matthrews/typescript-doc-gen",
  ];

  const bodyContent: string[] = [];

  interfaceCollection.forEach((interfaceItem) => {
    const {
      id: { name = "" },
      body: { body: properties = [] },
    } = interfaceItem;
    const contents = [`### ${name}\r\n`].concat(mdTemplate);

    properties.forEach((property) => {
      const {
        optional,
        key: { name = "" },
        leadingComments: [{ value = "" }],
        typeAnnotation: { typeAnnotation = {} },
      } = property;
      const type = parseTypeAnnotation(typeAnnotation);
      const required = optional ? "--" : "是";
      const comment = parseCommentBlock(value);
      const defaultValue = parseCommentBlock(value, "default") || "--";
      contents.push(
        `| ${name} | ${comment} | <code>${type}</code> | <code>${required}</code> | <code>${defaultValue}</code> |`
      );
    });

    contents.push("\r\n");

    bodyContent.push(contents.join("\r\n"));
  });

  const result = [mdTitle].concat(bodyContent).concat(extraInfo).join("\r\n");

  mkdirSync(resolve(outDir, "./md"));
  writeFileSync(`${resolve(outDir, "./md")}/API.md`, result);

  console.log("Finished!");
};

module.exports = {
  showSample,
  generateDoc,
};
